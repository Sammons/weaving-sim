/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst inchesBetweenNails = 0.32;\nconst inchesPerYard = 36;\nconst state = {\n    recentPicks: [],\n    currentPick: \"#0ff0ff\",\n    currentNails: 1,\n    selectAll: false,\n    useHexCodes: false,\n    selectedRows: [],\n    entries: []\n};\nfunction createElementFromHTML(htmlString) {\n    var div = document.createElement('tbody');\n    div.innerHTML = htmlString.trim();\n    // Change this to div.childNodes to support multiple top-level nodes\n    return div.firstElementChild;\n}\nconst constructRow = (value) => {\n    const proto = document.getElementById(elementIds.protoTable);\n    const html = proto.innerHTML;\n    const row = createElementFromHTML(html);\n    const cells = Array.from(row.children);\n    cells[0].innerHTML = String(value.idx);\n    const input = cells[1].firstElementChild;\n    input.onchange = (ev => {\n        const t = ev.target;\n        if (Number.isFinite(t.valueAsNumber)) {\n            value.nails = t.valueAsNumber;\n            updateDom();\n        }\n    });\n    input.value = String(value.nails);\n    cells[2].setAttribute('style', `background-color: ${value.color};`);\n    cells[3].innerHTML = value.selected ? '✓' : '';\n    [cells[0], cells[2], cells[3]].forEach(td => {\n        td.addEventListener('click', () => {\n            value.selected = !value.selected;\n            cells[3].innerHTML = value.selected ? '✓' : '';\n            if (value.selected) {\n                state.selectedRows.push(value.idx);\n            }\n            else {\n                const idx = state.selectedRows.findIndex(el => el === value.idx);\n                state.selectedRows.splice(idx, 1);\n            }\n            state.selectedRows.sort((a, b) => a - b);\n        });\n    });\n    return row;\n};\nconst updateLink = () => {\n    const data = btoa(JSON.stringify(state.entries));\n    const base = window.location.toString().replace(/\\?=?.*/, '');\n    const appended = ('#data=' + data);\n    const link = (base + appended).replace(/#+/, '#');\n    const linkText = document.getElementById(elementIds.linkText);\n    linkText.value = link;\n};\nconst updateDom = () => {\n    try {\n        console.log('updating table');\n        const table = document.getElementById(elementIds.dataTable);\n        state.entries.sort((a, b) => a.idx - b.idx);\n        const remappedIdxes = {};\n        state.entries.forEach((e, i) => {\n            remappedIdxes[e.idx] = i;\n            e.idx = i;\n        });\n        state.selectedRows.forEach((e, i) => {\n            state.selectedRows[i] = remappedIdxes[e];\n        });\n        if (table) {\n            Array.from(table.children).forEach(c => c.remove());\n            state.entries.forEach(entry => {\n                table.appendChild(constructRow(entry));\n            });\n        }\n        const quickPicks = Array.from(document.getElementsByClassName('quick-pick')).sort((a, b) => {\n            return Number(a.id.split('-').pop()) - Number(b.id.split('-').pop());\n        });\n        for (let i = 0; i < quickPicks.length; ++i) {\n            if (state.recentPicks[i] != null) {\n                quickPicks[i].removeAttribute('hidden');\n                quickPicks[i].setAttribute('style', `background-color: ${state.recentPicks[i]};`);\n                quickPicks[i]['_val'] = state.recentPicks[i];\n                if (!quickPicks[i]['listener']) {\n                    quickPicks[i].addEventListener('click', () => {\n                        setHexInputsToValue(quickPicks[i]['_val']);\n                    });\n                    quickPicks[i]['listener'] = true;\n                }\n            }\n            else {\n                quickPicks[i].setAttribute('hidden', \"true\");\n            }\n        }\n        // estimates\n        const nailsTotal = document.getElementById(elementIds.nailsTotal);\n        let nailSum = 0;\n        state.entries.forEach(e => nailSum += e.nails);\n        if (nailsTotal) {\n            nailsTotal.innerHTML = String(nailSum);\n        }\n        const yardage = document.getElementById(elementIds.yardsTotal);\n        const fringe = document.getElementById(elementIds.yardsFringe);\n        const hypotenus = document.getElementById(elementIds.hypotenus);\n        if (hypotenus) {\n            const distanceOnOneSide = nailSum * inchesBetweenNails;\n            const hypotenusValue = Math.sqrt((distanceOnOneSide * distanceOnOneSide) * 2);\n            const feet = Math.floor(hypotenusValue / 12);\n            const remainder = Math.ceil(hypotenusValue - (feet * 12));\n            hypotenus.innerHTML = `${feet}' ${remainder}\"`;\n        }\n        // if (yardage) {\n        //   let lengthOfOneSide = nailSum * inchesBetweenNails;\n        //   let lengthOfDiagonal = Math.sqrt(2 * (lengthOfOneSide * lengthOfOneSide)) * 2;\n        //   let netInches = nailSum * lengthOfDiagonal;\n        //   let yards = netInches / inchesPerYard;\n        //   const roundNum = (n: number) => {\n        //     const m = String(n).match(/(\\d+\\.?\\d{0,2})\\d*/);\n        //     return m ? m[1] : \"\";\n        //   }\n        //   yardage.innerHTML = roundNum(yards);\n        //   const _6InchFringeLengthPerNail = 12.0;\n        //   const _6InchFringeNeeded = _6InchFringeLengthPerNail * nailSum;\n        //   fringe!.innerHTML = `${roundNum(_6InchFringeNeeded / inchesPerYard)}`\n        // }\n        // capture\n        recalculateCanvas();\n        // save state\n        localStorage.setItem('state-v1', JSON.stringify(state));\n        updateLink();\n    }\n    catch (e) {\n        console.log(e);\n    }\n};\nconst recalculateCanvas = () => {\n    let nailSum = 0;\n    state.entries\n        .sort((a, b) => a.idx - b.idx)\n        .forEach(e => nailSum += e.nails);\n    if (state.entries.length === 0) {\n        return;\n    }\n    let curEntry = 0;\n    let strokeLen = 0;\n    const proportion = 120 / nailSum;\n    if (context) {\n        context.lineWidth = proportion;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        context.beginPath();\n        for (let i = 0; i < nailSum + 1; ++i) {\n            let width = canvas.width;\n            let height = canvas.height;\n            let offset = width / nailSum;\n            let p1 = { x: i * offset, y: height };\n            let p2 = { y: i * offset, x: width };\n            let p3 = { x: (nailSum - i) * offset, y: 0 };\n            let p4 = { y: (nailSum - i) * offset, x: 0 };\n            if (i == 0) {\n                context.moveTo(p1.x, p1.y);\n            }\n            else {\n                context.lineTo(p1.x, p1.y);\n            }\n            context.lineTo(p2.x, p2.y);\n            context.lineTo(p3.x, p3.y);\n            context.lineTo(p4.x, p4.y);\n            context.lineTo(p1.x, p1.y);\n            if (strokeLen >= state.entries[curEntry].nails) {\n                context.strokeStyle = state.entries[curEntry].color;\n                context.stroke();\n                context.closePath();\n                context.beginPath();\n                if (curEntry + 1 < state.entries.length) {\n                    curEntry++;\n                }\n                else {\n                    break;\n                }\n                strokeLen = 0;\n            }\n            else {\n                strokeLen++;\n            }\n        }\n        context.strokeStyle = state.entries[curEntry].color;\n        context.stroke();\n    }\n};\nconst addSelectionToTable = () => {\n    if (state.currentPick == null || state.currentNails == null || state.currentNails < 1) {\n        console.log('skipping adding selection, invalid form');\n        return;\n    }\n    state.entries.push({\n        idx: state.entries.length,\n        color: state.currentPick,\n        selected: false,\n        nails: state.currentNails\n    });\n    if (!new Set(state.recentPicks).has(state.currentPick)) {\n        state.recentPicks.unshift(state.currentPick);\n    }\n    updateDom();\n};\nconst copyRows = () => {\n    const selected = new Set(state.selectedRows);\n    const currentValues = state.entries.filter(e => {\n        return selected.has(e.idx);\n    });\n    currentValues.forEach(v => {\n        state.entries.push({\n            idx: state.entries.length,\n            color: v.color,\n            selected: false,\n            nails: v.nails\n        });\n    });\n    updateDom();\n};\nconst deleteRows = () => {\n    const selected = new Set(state.selectedRows);\n    const currentValues = state.entries.filter(e => {\n        return selected.has(e.idx);\n    });\n    currentValues.forEach(v => {\n        const curIdx = state.entries.findIndex(e => {\n            return e.idx === v.idx;\n        });\n        state.entries.splice(curIdx, 1);\n    });\n    state.selectedRows = [];\n    updateDom();\n};\nconst setHexInputsToValue = (hex) => {\n    const hexEl = document.getElementById(elementIds.hexColorInput);\n    const colorEl = document.getElementById(elementIds.normalColorInput);\n    if (hex != null) {\n        if (hex.match(/#[0-9a-fA-F]{6}/gm)) {\n            hexEl.value = hex;\n            colorEl.value = hex;\n            state.currentPick = hex;\n            return true;\n        }\n        else {\n            hexEl.value = \"\";\n            return false;\n        }\n    }\n};\nconst hexColorInputHandler = (e) => {\n    var _a;\n    const value = (_a = e.target) === null || _a === void 0 ? void 0 : _a.value;\n    if (value != null) {\n        setHexInputsToValue(value);\n    }\n};\nconst normalColorInputHandler = (e) => {\n    return hexColorInputHandler(e);\n};\nconst numberOfNailsInputHandler = (e) => {\n    const el = e.target;\n    const value = el.valueAsNumber;\n    if (Number.isFinite(value)) {\n        state.currentNails = value;\n    }\n    else {\n        el.value = \"\";\n    }\n};\nconst reverseRows = () => {\n    const selected = new Set(state.selectedRows);\n    const currentValues = state.entries.filter(e => {\n        return selected.has(e.idx);\n    });\n    const reversedIndexes = currentValues.map(v => v.idx).reverse();\n    for (let i = 0; i < currentValues.length; ++i) {\n        currentValues[i].idx = reversedIndexes[i];\n    }\n    updateDom();\n};\nconst elementIds = {\n    normalColorInput: 'color-selection',\n    normalColorInputLabel: 'color-selection-label',\n    hexColorInput: 'hex-color-selection',\n    hexColorInputLabel: 'hex-color-selection-label',\n    toggleHexInput: 'color-selection-type',\n    numberOfNailsInput: 'nail-selection',\n    addSelectionButton: 'add-selection',\n    copyRows: 'copy-rows',\n    reverseRows: 'reverse-rows',\n    deleteRows: 'delete-rows',\n    dataTable: 'data-table',\n    protoTable: 'prototype-row-container',\n    nailsTotal: 'nails-total',\n    yardsTotal: 'yards-total',\n    yardsFringe: 'yards-fringe',\n    hypotenus: 'hypotenus',\n    copyLink: 'copy-link',\n    linkText: 'link-text',\n    selectAllToggle: 'select-all-toggle'\n};\nconst toggleHexInputHandler = (e) => {\n    const checkbox = e.target;\n    const checked = checkbox.checked;\n    state.useHexCodes = checked;\n    const el = document.getElementById(elementIds.normalColorInput);\n    const label = document.getElementById(elementIds.normalColorInputLabel);\n    const el2 = document.getElementById(elementIds.hexColorInput);\n    const label2 = document.getElementById(elementIds.hexColorInputLabel);\n    if (el) {\n        el.hidden = state.useHexCodes;\n    }\n    if (label) {\n        label.hidden = state.useHexCodes;\n    }\n    if (el2) {\n        el2.hidden = !state.useHexCodes;\n    }\n    if (label2) {\n        label2.hidden = !state.useHexCodes;\n    }\n};\nconst fixedElementHandlers = {\n    addSelectionButton: addSelectionToTable,\n    copyRows: copyRows,\n    deleteRows: deleteRows,\n    // TODO: needs to pass el\n    hexColorInput: hexColorInputHandler,\n    normalColorInput: normalColorInputHandler,\n    numberOfNailsInput: numberOfNailsInputHandler,\n    reverseRows: reverseRows,\n    toggleHexInput: toggleHexInputHandler,\n    selectAllToggle: () => {\n        console.log('select all');\n        if (!state.selectAll) {\n            state.selectAll = true;\n            state.selectedRows = state.entries.map(e => {\n                e.selected = true;\n                return e.idx;\n            });\n        }\n        else {\n            state.entries.forEach(e => {\n                e.selected = false;\n            });\n            state.selectAll = false;\n            state.selectedRows = [];\n        }\n        updateDom();\n    }\n};\nconst handlers = () => {\n    const el = document.getElementById(elementIds.toggleHexInput);\n    if (el) {\n        el.checked = state.useHexCodes;\n    }\n    const colorInput = document.getElementById(elementIds.hexColorInput);\n    if (colorInput) {\n        setHexInputsToValue(state.currentPick);\n    }\n    const nailInput = document.getElementById(elementIds.numberOfNailsInput);\n    if (nailInput) {\n        nailInput.value = String(state.currentNails);\n    }\n    // fixed handlers\n    Object.keys(fixedElementHandlers).forEach(key => {\n        const k = key;\n        const element = document.getElementById(elementIds[k]);\n        const configuredHandler = fixedElementHandlers[k];\n        fixedElementHandlers[k] = ((event) => {\n            return configuredHandler(event);\n        });\n        if (element) {\n            element.addEventListener('change', (e) => {\n                return fixedElementHandlers[k](e);\n            });\n            element.addEventListener('click', (e) => {\n                return fixedElementHandlers[k](e);\n            });\n        }\n    });\n    const stored = localStorage.getItem('state-v1');\n    if (stored) {\n        Object.assign(state, JSON.parse(stored));\n    }\n    if (window.location.hash && window.location.hash.includes('=')) {\n        const hashData = window.location.hash.replace('#data=', '');\n        try {\n            console.log(hashData);\n            state.entries = JSON.parse(atob(hashData));\n        }\n        catch (e) {\n            console.log(e);\n        }\n        window.location.hash = \"\";\n    }\n    updateDom();\n};\nconst canvas = document.getElementById('canvas');\ncanvas.width = 512;\ncanvas.height = 512;\nconst context = canvas.getContext('2d');\nif (context) {\n    context.fillStyle = 'blue';\n    context.fillRect(0, 0, canvas.width, canvas.height);\n}\nconst main = () => {\n    handlers();\n};\nmain();\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"](0, __webpack_exports__);
/******/ 	
/******/ })()
;